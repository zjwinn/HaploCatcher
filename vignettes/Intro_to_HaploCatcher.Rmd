---
title: "Introduction to HaploCatcher"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to HaploCatcher}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

The HaploCatcher package is based off the work done in Winn et al (2022) which demonstrated that relatively simple machine learning models could be used to generate haplotype information for genome wide genotyped lines. The idea behind this approach was to leverage the historical PCR based marker information in programs to identify haplotypes of interest in early generation material which has been sequenced for genomic selection. This approach offers several distinct advantages for breeding programs:  

1. Lines which are genotyped for genomic selection in early generations, which would not have PCR based markers ran on them, can revive haplotype information which they would otherwise not have. 

2. Users can apply this information for selection of desirable haplotypes in early generations.  

3. Haplotype information could become available earlier in the breeding process. 

4. Haplotypes could be predicted for historical lines for use in estimation of locus effects across time.  

It was the desire of the development team for HaploCatcher to make a package available for individuals to apply this method in their programs with as little intervention as possible.

In this demonstration we will discuss the potential uses of this package and the file formats required to run the functions in the HaploCatcher package. 

# Data Structure - Gene Compendium

The data structure of the HaploCatcher package is paramount for its use. Lets take a look at the three necessary data frames that must be available to use this package.

```{r setup}
#library
library(HaploCatcher)

#read data from package
data("geno_mat")
data("gene_comp")
data("marker_info")
```

There are three different data frames included in the HaploCatcher package; "geno_mat", "gene_comp", and "marker_info". First, lets look at the head of the "gene_comp" file.

```{r, head_gene_comp, echo=FALSE}
knitr::kable(head(gene_comp), align = "c", caption = "Gene Compendium Input File")
```

The gene_comp file is a categorization file made by the user for their specific program. In this file there are seven columns. This is notated as the "gene compendium" or gene_comp for short. 

- Trait defines what trait the locus affects; in this case, we are looking at *Sst1* which affects resistance to sawfly in wheat.

- Chromosome defines what chromosome the gene is located on. This will be specific to a marker_information file later on. 

- Gene defines the name of the gene.

- Nursery defines what nursery/program the information was derived from.

- Line defines the "line designation" given to a genotype. The line designation is denoted by the breeder.

- FullSampleName is the name of the line which matches with the row names in the marker matrix.

- Call is the haplotype for that line for that gene. This call column is very important for the functioning of the HaploCatcher package. This package only predicts biallelic loci. The locus can be only homozygous cases or include a heterozygous case. 

For simplicity in the package, calls for gene haplotypes should be formatted like this 

```{r, display_calls, echo=FALSE}
knitr::kable(data.frame(Call=unique(gene_comp$Call)), align = "c", caption = "Haplotype Calls")
```

where the name of the gene "sst1_solid_stem" is the homozygous positive case, the heterozygous case has the string "het_" in front of it like "het_sst1_solid_stem" and the negative case has the string "non_" in front of it like "non_sst1_solid_stem". 

If the user was only providing the positive and negative cases, without the heterozygous case, the format would be the same without "het_" category.  

To use the package properly, users must have at least four columns in the data present: FullSampleName, Chromosome, Gene, and Call. Other data may be present, but those columns, *both properly named and case correct*, must be present in the data.  

For example, if the user was trying to predict the Pm34 locus in wheat with heterozgyous cases, the data frame for the gene_comp would look like this:

```{r, data_example, echo=FALSE, echo=FALSE}
a<-data.frame(FullSampleName=c("Geno_1", "Geno_2", "Geno_3"),
              Chromosome=rep("5D", 3),
              Gene=rep("pm34", 3),
              Call=c("pm34", "het_pm34", "non_pm34"))
knitr::kable(a, align = "c", caption = "Pm34 Example Input File")
```

# Data Structure - Genotypic Matrix

The structure of the genotypic matrix is a full-rank (no missing data) numeric matrix.

```{r, head_geno_mat, echo=FALSE}
#must define as a matrix
geno_mat<-as.matrix(geno_mat)

#see head
knitr::kable(geno_mat[1:5, 1:5], align = "c", caption = "Marker Matrix Input File")
```

Where the columns of the matrix are markers, the rows of the matrix are genotypes, and the the marker information is coded numerically. In the marker matrix provided in the package is coded 0,1,2 where 0 is the major allele, 1 is the heterozygous haplotype, and 2 is the minor allele. The coding of the matrix must always be numeric, but it can be in any numeric format as long as the numbers are real integers.

 ***Note: the column names must match information provided in the marker info file (see next section) and the row names must match the "FullSampleName" provided in the gene_comp!***

# Data Structure - Marker Information

The marker_info file contains information on all the markers found in the columns of the geno_mat file.

```{r, head_marker_info, echo=FALSE}
knitr::kable(head(marker_info), align = "c", caption = "Marker Info Input File")
```

The marker_info file has three required columns:

- Marker is the name of the marker which is found in the column names of the marker matrix

- Chromosome is the name of the chromosome (or linkage group) that the marker belongs to

- BP_Position is the base pair position of the marker. This can be replaced by a numeric dummy variable or a centimorgan position!

Below is an example where a linkage group and centimorgan position is provided. 

```{r, marker_info_example, echo=FALSE}
a<-data.frame(Marker=c("TRACE_00102",
                       "TRACE_13112",
                       "TRACE_43821"),
              Chromosome=c(1, 1, 1),
              BP_Position=c(0.0,
                            0.5,
                            1.2))
knitr::kable(a, align = "c", caption = "Marker Info Input File Example")
```

***Note: even though these are not chromosomes or basepair positions, you must leave the names of the columns titled as such! Furthermore, the columns for the marker_info and geno_comp are case sensitive***
