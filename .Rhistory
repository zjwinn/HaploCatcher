results<-auto_locus(geno_mat = geno_mat,
gene_file = gene_comp,
gene_name = "sst1_solid_stem",
marker_info = marker_info,
chromosome = "3B",
training_genotypes = training_genotypes,
testing_genotypes = testing_genotypes,
set_seed = 022294,
n_perms = 2,
ncor_markers = 2)
#run auto_locus base function with minimum needed input for three iterations
results<-auto_locus(geno_mat = geno_mat,
gene_file = gene_comp,
gene_name = "sst1_solid_stem",
marker_info = marker_info,
chromosome = "3B",
training_genotypes = training_genotypes,
testing_genotypes = testing_genotypes,
set_seed = 022294,
n_perms = 2,
ncor_markers = 2)
set_seed = 022294
n_perms = 2
ncor_markers = 2
training_genotypes = training_genotypes
testing_genotypes = testing_genotypes
chromosome = "3B"
marker_info = marker_info
gene_name = "sst1_solid_stem"
gene_file = gene_comp
geno_mat = geno_mat
cv_percent_testing=0.2
cv_percent_training=0.8
model_selection_parameter="kappa"
set_seed=NULL
predict_by_vote=FALSE
include_hets=FALSE
include_models=FALSE
verbose=TRUE
parallel=FALSE
n_cores=NULL
plot_cv_results=TRUE
#announce
if(verbose==TRUE){
#print
base::print(base::paste("Performing cross validation analysis for ", gene_name, "...", sep = ""))
}
#check and stop
if(predict_by_vote==FALSE & is.null(set_seed)){
stop("User must define a seed to proceed with pipeline without voting! Either set 'predict_by_vote' to TRUE or set 'set_seed' to a random intiger!" )
}
set_seed=1
#pull training population out of the data
train_geno_mat<-geno_mat[rownames(geno_mat) %in% training_genotypes,]
train_gene_file<-gene_file[gene_file$FullSampleName %in% training_genotypes,]
#first perform CV
fit_cv<-HaploCatcher::locus_perm_cv(n_perms = n_perms, #the number of permutations
geno_mat = train_geno_mat, #the genotypic matrix
gene_file = train_gene_file, #the gene compendium file
gene_name = gene_name, #the name of the gene
marker_info = marker_info, #the marker information file
chromosome = chromosome, #name of the chromosome
ncor_markers = ncor_markers, #number of markers to retain
percent_testing = cv_percent_testing, #percentage of genotypes in the validation set
percent_training = cv_percent_training, #percentage of genotypes in the training set
include_hets = include_hets, #excludes hets in the model
include_models = include_models, #excludes models in results object
verbose = verbose, #excludes text
parallel = parallel, #should it be in parallel
n_cores = n_cores) #if so, how many cores
View(fit_cv)
#announce
if(verbose==TRUE){
#print
base::print("Done!")
}
#plot results
if(plot_cv_results==TRUE){
HaploCatcher::plot_locus_perm_cv(fit_cv)
}
#check the model selection parameter
if(!model_selection_parameter=="kappa" & !model_selection_parameter=="accuracy"){
warning("Neither kappa nor accuracy were set as model selection parameters; defaulting to kappa.")
model_selection_parameter="kappa"
}
#pull out the optimal model
if(model_selection_parameter=="kappa"){
#pull model
model_selected<-fit_cv$Overall_Summary[fit_cv$Overall_Summary$Mean_Kappa==max(fit_cv$Overall_Summary$Mean_Kappa),"Model"]
#rename
if (model_selected=="Random Forest"){
model_selected="rf"
}else if(model_selected=="K-Nearest Neighbors"){
model_selected="knn"
}else{
message("Note: There was a tie between models in terms of kappa, selecting model at random...")
model_selected=data.frame(a=c("knn", "rf"),
rand=stats::rnorm(2, mean = 10000000, sd=30000))
model_selected=as.character(model_selected[model_selected$rand==max(model_selected$rand), 1])
}
}else if (model_selection_parameter=="accuracy"){
#pull model
model_selected<-fit_cv$Overall_Summary[fit_cv$Overall_Summary$Mean_Accuracy==max(fit_cv$Overall_Summary$Mean_Accuracy),"Model"]
#change name
if (model_selected=="Random Forest"){
model_selected="rf"
}else if(model_selected=="K-Nearest Neighbors"){
model_selected="knn"
}else{
message("Note: There was a tie between models in terms of accuracy, selecting model at random...")
model_selected=data.frame(a=c("knn", "rf"),
rand=stats::rnorm(2, mean = 10000000, sd=30000))
model_selected=as.character(model_selected[model_selected$rand==max(model_selected$rand), 1])
}
}
if(verbose==TRUE){print(paste("The best performing model in cross-validation in terms of ",
model_selection_parameter,
" was ",
ifelse(model_selected=="knn",
"k-nearest neighbors",
"random forest"),
". Moving onto forward prediction!",
sep=""))}
#pull out the optimal model
if(model_selection_parameter=="kappa"){
#pull model
model_selected<-fit_cv$Overall_Summary[fit_cv$Overall_Summary$Mean_Kappa==max(fit_cv$Overall_Summary$Mean_Kappa),"Model"]
#rename
if (model_selected=="Random Forest"){
model_selected="rf"
}else if(model_selected=="K-Nearest Neighbors"){
model_selected="knn"
}else{
message("Note: There was a tie between models in terms of kappa, selecting model at random...")
model_selected=data.frame(a=c("knn", "rf"),
rand=stats::rnorm(2, mean = 10000000, sd=30000))
model_selected=as.character(model_selected[model_selected$rand==max(model_selected$rand), 1])
}
}else if (model_selection_parameter=="accuracy"){
#pull model
model_selected<-fit_cv$Overall_Summary[fit_cv$Overall_Summary$Mean_Accuracy==max(fit_cv$Overall_Summary$Mean_Accuracy),"Model"]
#change name
if (model_selected=="Random Forest"){
model_selected="rf"
}else if(model_selected=="K-Nearest Neighbors"){
model_selected="knn"
}else{
message("Note: There was a tie between models in terms of accuracy, selecting model at random...")
model_selected=data.frame(a=c("knn", "rf"),
rand=stats::rnorm(2, mean = 10000000, sd=30000))
model_selected=as.character(model_selected[model_selected$rand==max(model_selected$rand), 1])
}
}
if(verbose==TRUE){print(paste("The best performing model in cross-validation in terms of ",
model_selection_parameter,
" was ",
ifelse(model_selected=="knn",
"k-nearest neighbors",
"random forest"),
". Moving onto forward prediction!",
sep=""))}
if(predict_by_vote==TRUE){
if(parallel==TRUE){
#set cores
if(is.null(n_cores)){
n_cores=parallel::detectCores()-1
}
#assign cluster
cluster<-parallel::makeCluster(n_cores)
doParallel::registerDoParallel(cluster)
#announce
if(verbose==TRUE){
print("Running permutations in parallel! All text output suppressed!")
}
#run parallel loop
results<-foreach::foreach(i=1:n_votes) %dopar% {
#train model
fit<-HaploCatcher::locus_train(geno_mat = train_geno_mat, #the genotypic matrix
gene_file = train_gene_file, #the gene compendium file
gene_name = gene_name, #the name of the gene
marker_info = marker_info, #the marker information file
chromosome = chromosome, #name of the chromosome
ncor_markers = ncor_markers, #number of markers to retain
include_hets = include_hets, #include hets in the model
verbose = verbose, #allows for text and graph output
set_seed = set_seed, #sets a seed for reproduction of results
models_request = model_selected) #sets what models are requested
#make a prediction
pred<-HaploCatcher::locus_pred(locus_train_results=fit,
geno_mat=geno_mat,
genotypes_to_predict=testing_genotypes)
return(pred)
}
#stop the cluster
parallel::stopCluster(cluster)
#re-register sequential
foreach::registerDoSEQ()
a<-data.frame(FullSampleName=results[[1]]$FullSampleName)
for(i in 1:n_votes){
a[,paste("Vote_",i,sep = "")]=results[[i]][,2]
}
b<-c()
for(i in 1:nrow(a)){
c<-as.data.frame(table(t(a[i,2:ncol(a)])))
d<-c
e<-levels(a[,2])
e<-data.frame(Var1=e)
d<-merge(d,e, all=T)
d$Freq=ifelse(is.na(d$Freq), 0,d$Freq)
d<-t(d)
colnames(d)=d[1,]
d<-d[-1,]
d<-as.data.frame(t(d))
rownames(d)=NULL
c<-data.frame(FullSampleName=a[i,1],
Consensus_Call=ifelse(length(c[c$Freq==max(c$Freq), "Var1"])>1, "No_Call", as.character(c[c$Freq==max(c$Freq), "Var1"])),
d)
b<-rbind(b,c)
remove(c,d,e)
}
#make results object
return_results<-list(method="multiple models - majority rule",
cross_validation_results=fit_cv,
predictions=a,
consensus_predictions=b)
return(return_results)
}else if(parallel==FALSE){
results<-list()
for(i in 1:n_votes){
#train model
fit<-HaploCatcher::locus_train(geno_mat = train_geno_mat, #the genotypic matrix
gene_file = train_gene_file, #the gene compendium file
gene_name = gene_name, #the name of the gene
marker_info = marker_info, #the marker information file
chromosome = chromosome, #name of the chromosome
ncor_markers = ncor_markers, #number of markers to retain
include_hets = include_hets, #include hets in the model
verbose = verbose, #allows for text and graph output
set_seed = set_seed, #sets a seed for reproduction of results
models_request = model_selected) #sets what models are requested
#make a prediction
pred<-HaploCatcher::locus_pred(locus_train_results=fit,
geno_mat=geno_mat,
genotypes_to_predict=testing_genotypes)
results[[i]]<-pred
}
a<-data.frame(FullSampleName=results[[1]]$FullSampleName)
for(i in 1:n_votes){
a[,paste("Vote_",i,sep = "")]=results[[i]][,2]
}
b<-c()
for(i in 1:nrow(a)){
c<-as.data.frame(table(t(a[i,2:ncol(a)])))
d<-c
e<-levels(a[,2])
e<-data.frame(Var1=e)
d<-merge(d,e, all=T)
d$Freq=ifelse(is.na(d$Freq), 0,d$Freq)
d<-t(d)
colnames(d)=d[1,]
d<-d[-1,]
d<-as.data.frame(t(d))
rownames(d)=NULL
c<-data.frame(FullSampleName=a[i,1],
Consensus_Call=ifelse(length(c[c$Freq==max(c$Freq), "Var1"])>1, "No_Call", as.character(c[c$Freq==max(c$Freq), "Var1"])),
d)
b<-rbind(b,c)
remove(c,d,e)
}
#make results object
return_results<-list(method="multiple models - majority rule",
cross_validation_results=fit_cv,
predictions=a,
consensus_predictions=b)
return(return_results)
}
}else if(predict_by_vote==FALSE){
#train model
fit<-HaploCatcher::locus_train(geno_mat = train_geno_mat, #the genotypic matrix
gene_file = train_gene_file, #the gene compendium file
gene_name = gene_name, #the name of the gene
marker_info = marker_info, #the marker information file
chromosome = chromosome, #name of the chromosome
ncor_markers = ncor_markers, #number of markers to retain
include_hets = include_hets, #include hets in the model
verbose = verbose, #allows for text and graph output
set_seed = set_seed, #sets a seed for reproduction of results
models_request = model_selected) #sets what models are requested
#make a prediction
pred<-HaploCatcher::locus_pred(locus_train_results=fit,
geno_mat=geno_mat,
genotypes_to_predict=testing_genotypes)
return_results<-list(method="single model - single prediction",
cross_validation_results=fit_cv,
prediction_model=fit,
predictions=pred)
return(return_results)
}else{
stop("The function parameter 'predict_by_vote' must be a logical argument (TRUE/FALSE)!")
}
#set seed
base::set.seed(set_seed)
#check if
if(!gene_name %in% gene_file$Gene){
stop("Error:'gene_name' not found in 'geno_file'!")
}
#make dataset
classification<-gene_file[gene_file$Gene==gene_name,]
#check if
if(length(classification$FullSampleName[base::duplicated(classification$FullSampleName)])>0){
base::stop("Error: There are duplicated individuals in the 'gene_file'!")
}else if(base::class(base::try(base::ncol(gene_file[,c("Gene", "FullSampleName", "Call")])))=="try-error"){
base::stop("Error: The 'gene_file' does not have the columns 'Gene', 'FullSampleName', and 'Call'!")
}
#check if
if(include_hets==FALSE){
if(verbose==TRUE){base::print("Note: Removing heterozygous calls from the dataframe")}
classification<-classification[!classification$Call %in% classification$Call[grep("het_", classification$Call)], ]
}else if(!is.logical(include_hets)){
base::stop("Error: Argument 'include_hets' must be a logical argument! (TRUE or FALSE)")
}else{
if(verbose==TRUE){base::print("Note: User has requested heterozygous calls remain in the dataset")}
}
#pull genetic information for individuals
geno_matrix<-geno_mat[base::rownames(geno_mat) %in% classification$FullSampleName,]
#check if
if(base::class(base::try(base::ncol(marker_info[,c("Marker", "Chromosome", "BP_Position")])))=="try-error"){
base::stop("Error: columns are misnamed or missing in the 'marker_info'!")
}else if(!chromosome %in% marker_info$Chromosome){
base::stop("Error: 'chromosome' is not defined in the 'marker_info' chromosome column!")
}
#check if
if(!models_request %in% c("knn","rf","all")){
base::stop("Error: 'models_request' is incorrect, use either 'knn', 'rf', or 'all'!")
}
models_request = model_selected
#set seed
base::set.seed(set_seed)
#check if
if(!gene_name %in% gene_file$Gene){
stop("Error:'gene_name' not found in 'geno_file'!")
}
#make dataset
classification<-gene_file[gene_file$Gene==gene_name,]
#check if
if(length(classification$FullSampleName[base::duplicated(classification$FullSampleName)])>0){
base::stop("Error: There are duplicated individuals in the 'gene_file'!")
}else if(base::class(base::try(base::ncol(gene_file[,c("Gene", "FullSampleName", "Call")])))=="try-error"){
base::stop("Error: The 'gene_file' does not have the columns 'Gene', 'FullSampleName', and 'Call'!")
}
#check if
if(include_hets==FALSE){
if(verbose==TRUE){base::print("Note: Removing heterozygous calls from the dataframe")}
classification<-classification[!classification$Call %in% classification$Call[grep("het_", classification$Call)], ]
}else if(!is.logical(include_hets)){
base::stop("Error: Argument 'include_hets' must be a logical argument! (TRUE or FALSE)")
}else{
if(verbose==TRUE){base::print("Note: User has requested heterozygous calls remain in the dataset")}
}
#pull genetic information for individuals
geno_matrix<-geno_mat[base::rownames(geno_mat) %in% classification$FullSampleName,]
#check if
if(base::class(base::try(base::ncol(marker_info[,c("Marker", "Chromosome", "BP_Position")])))=="try-error"){
base::stop("Error: columns are misnamed or missing in the 'marker_info'!")
}else if(!chromosome %in% marker_info$Chromosome){
base::stop("Error: 'chromosome' is not defined in the 'marker_info' chromosome column!")
}
#check if
if(!models_request %in% c("knn","rf","all")){
base::stop("Error: 'models_request' is incorrect, use either 'knn', 'rf', or 'all'!")
}
#subset markers
selected_markers<-marker_info[marker_info$Chromosome==chromosome,]
#pull markers
geno_matrix<-geno_matrix[,base::colnames(geno_matrix) %in% selected_markers$Marker]
#order the markers
geno_matrix<-geno_matrix[base::order(base::rownames(geno_matrix)), ]
#order the fullsamplenames in training
training<-classification[base::order(classification$FullSampleName),]
#cbind
training<-base::cbind(training, geno_matrix)
#check if
if(base::unique(training$FullSampleName %in%  base::rownames(geno_matrix))>1){
base::stop("Error: Individuals in the training parition are not found in the 'geno_mat'!")
}
#make a correlation set
corr<-training[,c("Call", base::colnames(geno_matrix))]
corr$Call<-base::match(corr$Call, unique(corr$Call))
corr[,1:base::ncol(corr)]<-base::lapply(corr[,1:base::ncol(corr)], base::as.numeric)
#perform correlation
corr<-base::suppressWarnings(stats::cor(corr))
corr<-base::round(corr, 10)
corr<-base::data.frame("|r|"=corr[-1,1],
check.names = FALSE)
corr$`|r|`<-base::abs(corr$`|r|`)
corr$marker<-base::rownames(corr)
corr$BP_Position<-selected_markers$BP_Position
corr$MBP_Position<-base::round(base::as.numeric(corr$BP_Position)/1000000, 2)
#plot results
if(graph==TRUE){
base::plot(x=corr$MBP_Position,
y=corr$`|r|`,
main = base::paste("Correlational Study of markers on", chromosome, "for", gene_name),
xlab = "Megabasepair (Mbp) Position",
ylab = "Absolute Value of Correlation (|r|)")
}
#plot threshold
corr<-corr[base::order(corr$`|r|`, decreasing = TRUE),]
corr<-corr[1:ncor_markers,]
#plot threshold line
if(graph==TRUE){
graphics::abline(h=min(corr$`|r|`), col = "red", lty=2)
graphics::legend("bottomleft",legend=base::paste("Top", ncor_markers, "correlated markers thresold"),  col = "red", lty = 2 )
}
#pull markers in training
training<-training[,
c("FullSampleName",
"Call",
corr$marker)]
#format datasets
training[,1:2]<-base::lapply(training[,1:2], base::as.factor)
training[,3:base::ncol(training)]<-base::lapply(training[,3:base::ncol(training)], base::as.numeric)
#show frequency in the testing population
if(verbose==TRUE){
a<-base::data.frame(base::table(training$Call)/ base::nrow(training))
base::colnames(a)=c("Call", "Frequency")
print(knitr::kable(a, caption = "Frequency of Calls in Training", digits = 2))
}
#make sure they are dataframes
training<-base::as.data.frame(training)
#make folds
fold<-caret::createFolds(training[,2], k = 5)
#make train control
cont_train<-caret::trainControl(classProb = TRUE,
verboseIter = FALSE,
savePredictions = TRUE,
index = fold,
number = 5,
repeats = 1000,
method = "repeatedcv")
#send message
if(verbose==TRUE){print("Note: Running Models...")}
#check number of markers
if(ncor_markers<=2){
#make alternate grid
grid_tune<-base::expand.grid(k = base::seq(from = 1,
to = 50,
by = 2))
}else{
#make grid
grid_tune<-base::expand.grid(k = base::seq(from = 1,
to = (base::ncol(test)-2),
by = 2))
}
#fit model
if(models_request=="all" | models_request=="knn"){
fit_1<-caret::train(Call ~ .,
data = training[,-1],
method = "knn",
tuneGrid = grid_tune,
trControl = cont_train)
}
#make grid
grid_tune<-base::expand.grid(mtry = c(1, base::seq(from = 5,
to = (base::ncol(training)-2),
by = 5)))
library(HaploCatcher)
#run auto_locus base function with minimum needed input for three iterations
results<-auto_locus(geno_mat = geno_mat,
gene_file = gene_comp,
gene_name = "sst1_solid_stem",
marker_info = marker_info,
chromosome = "3B",
training_genotypes = training_genotypes,
testing_genotypes = testing_genotypes,
set_seed = 022294,
n_perms = 2,
ncor_markers = 2)
#read in the genotypic data matrix
data("geno_mat")
#read in the marker information
data("marker_info")
#read in the gene compendium file
data("gene_comp")
#split the total data into training and test
set.seed(022294)
training_genotypes=sample(rownames(geno_mat), size = round(nrow(geno_mat)*0.8, 0))
testing_genotypes=rownames(geno_mat)[!rownames(geno_mat) %in% training_genotypes]
set.seed(NULL)
#run auto_locus base function with minimum needed input for three iterations
results<-auto_locus(geno_mat = geno_mat,
gene_file = gene_comp,
gene_name = "sst1_solid_stem",
marker_info = marker_info,
chromosome = "3B",
training_genotypes = training_genotypes,
testing_genotypes = testing_genotypes,
set_seed = 022294,
n_perms = 2,
ncor_markers = 2)
geno_mat = geno_mat
gene_file = gene_comp
gene_name = "sst1_solid_stem"
marker_info = marker_info
chromosome = "3B"
training_genotypes = training_genotypes
testing_genotypes = testing_genotypes
set_seed = 022294
n_perms = 2
ncor_markers = 2
help(package="HaploCatcher")
vignette(package="HaploCatcher")
